<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>lazyload throttle</title>
    <link rel="stylesheet" href="http://axuebin.com/lazyload/normalize.css">
    <link rel="stylesheet" href="index.css">
</head>

<body>
    <div class="container">
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img1.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img2.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img3.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img4.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img5.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img6.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img7.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img8.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img9.png"></div>
        <div class="img-area"><img src="" alt="loading" class="my-photo lazyimg" data-src="http://axuebin.com/lazyload/img/img10.png"></div>
    </div>
    <script>
        //debonce   throttle   都是用于节流的
        //性能问题，如果都给src，请求数并发太多
        //浏览器对http请求数有限制，5-6个线程  C++来编写，多线程
        //chrome请求数比较多 打开网页更快  有代价的，牺牲了内存
        //打卡页面就会变慢js优化，第一个就是减少http请求数
        //script src把所有的js打包成一个文件 main.js import require模块化最后一键打包再压缩，
        //只有一个js文件bundel.min.css  减少了http请求数  首屏打开速度，静态资源会缓存
        //link href   也同样可以打包，bundle.min.css
        //img src  zanwei.gif  eg:loading.gif/png/jpg  只会下载一次，到本地来   真正的图片地址放在data-src  origin-src里  
        //css中可以用雪碧图来节流，较少性能，可以减少http请求
        // iframe  
        const imgs = document.querySelectorAll('.lazyimg')
        window.onload = checkImgs
        //页面加载完成，检查一下图片，如果图片在第一屏，显示出来
        window.onscroll = throttle(checkImgs)  //checkImgs作为参数加入到了throttle中
        //滚动时，浏览器是个窗口， viewport对应的网页内容，scrolltop之后对应的网页内容发生变化，
        //滚过的那块区域，是否有还未显示的图片，如果有，则将其显示出来
        //throttle节流  不要执行的太频繁，否则占用内存过高
        //此时就形成了高阶函数的应用场景，增强了函数的功能，闭包其实也是高阶函数的应用场景
        function loadImg(el) {
            const src = el.dataset.src
            if (src !== el.src) {
                const source = src//将真正的地址取出来
                let img = document.createElement('img')
                img.onload = function () {
                    el.src = source
                }
                img.src = source
            }
        }

        function isInsight(el) {
            const bound = el.getBoundingClientRect()
            const clientHeight = window.innerHeight
            console.log(bound, clientHeight)
            //console.log(bound)
            return bound.top <= clientHeight + 100
        }

        function checkImgs() {
            //console.log('checkImgs')
            //首先找到图片
            for ([i, img] of Array.from(imgs).entries()) {
                //Array类数组变成真正的数组
                //entries方法就是迭代器，generator .next
                //console.log(i)
                //console.log(img)
                if (isInsight(imgs[i])) {
                    loadImg(imgs[i])
                }
            }
        }

        function throttle(fn, mustRun = 500) {
            //mustRun是默认值，执行0.5秒，可传可不传
            const timer = null
            let previous = null
            return function () {
                //因为window.onscroll引用的是一个函数,所以应该返回一个函数，此时高阶函数成为了闭包
                const now = new Date()
                const that = this
                const args = arguments
                if (!previous) {
                    previous = now
                }
                const remaining = now - previous
                if (mustRun && remaining >= mustRun) {
                    fn.apply(that, args)
                    previous = now
                }
            }
        }
    </script>
</body>

</html>


<!-- http://axuebin.com/blog/2017/08/19/javascript-lazyload/?utm_source=tuicool&utm_medium=referral -->